package event

import (
	"errors"
	"log"
	"regexp"
	"strconv"
	"strings"

	"github.com/byuoitav/common/events"
	"github.com/byuoitav/shure-audio-microservice/state"
	"github.com/fatih/color"
)

const FLAG = "ingored"

//wrapper for event types
type Context struct {
	E MicEvent
}

func (c *Context) FillEventInfo(data string, eventInfo *events.EventInfo) error {
	return c.E.FillEventInfo(data, eventInfo)
}

type MicEvent interface {
	//Fills EventInfo.EventInfoKey, EventInfo.EventInfoValue, EventInfo.Type, and EventInfo.EventCause
	//@pre: data does not contain the mic channel
	FillEventInfo(string, *events.EventInfo) error
}

type Interference struct{}

func (p Interference) FillEventInfo(data string, eventInfo *events.EventInfo) error {

	eventInfo.EventInfoKey = "interference"
	eventInfo.EventCause = events.AUTOGENERATED

	if strings.Contains(data, state.None.String()) { //no interference
		eventInfo.EventInfoValue = state.None.String()
		eventInfo.Type = events.DETAILSTATE
	} else if strings.Contains(data, state.Critical.String()) { //interference
		eventInfo.EventInfoValue = state.Critical.String()
		eventInfo.Type = events.ERROR
	} else { //bad data
		return errors.New("Invalid interference data detected")
	}
	return nil
}

type Power struct{}

func (p Power) FillEventInfo(data string, eventInfo *events.EventInfo) error {

	eventInfo.EventInfoKey = "power"
	eventInfo.Type = events.CORESTATE

	if strings.Contains(data, "UNKN") {
		eventInfo.EventInfoValue = "standby"
		eventInfo.EventCause = events.AUTOGENERATED
	} else {
		eventInfo.EventInfoValue = "on"
		eventInfo.EventCause = events.STARTUP
	}

	return nil
}

type Battery struct{}

func (p Battery) FillEventInfo(data string, eventInfo *events.EventInfo) error {

	log.Printf("Filling battery event info for message %s...", data)

	eventInfo.Type = events.DETAILSTATE
	eventInfo.EventCause = events.AUTOGENERATED

	if strings.Contains(data, state.Cycles.String()) {

		eventInfo.EventInfoKey = "battery cycles"
		re := regexp.MustCompile("[1-9][0-9]*")
		batteryCycles := re.FindString(data)
		color.Set(color.FgYellow)
		log.Printf("Found cycles: %s", batteryCycles)
		color.Unset()

		switch batteryCycles {
		case "65535":
			eventInfo.EventInfoValue = FLAG
		case "":
			eventInfo.EventInfoValue = "0"
		default:
			eventInfo.EventInfoValue = batteryCycles
		}

		return nil

	} else if strings.Contains(data, state.RunTime.String()) {

		eventInfo.EventInfoKey = "battery charge (minutes remaining)"
		re := regexp.MustCompile("[1-9][0-9]*")
		runTime := re.FindString(data)

		color.Set(color.FgYellow)
		log.Printf("Found run time: %s", runTime)
		color.Unset()

		switch runTime {
		case "65535":
			eventInfo.EventInfoValue = FLAG
		case "65534":
			eventInfo.EventInfoValue = "calculating"
		case "":
			eventInfo.EventInfoValue = "0"
		default:
			eventInfo.EventInfoValue = runTime
		}

		return nil

	} else if strings.Contains(data, state.Type.String()) {

		eventInfo.EventInfoKey = "battery type"

		re := regexp.MustCompile("[\\s][A-Z]{4}[\\s]")
		batteryType := re.FindString(data)

		if batteryType == " UNKN " {
			eventInfo.EventInfoValue = "Unknown"
		} else {
			eventInfo.EventInfoValue = batteryType[1 : len(batteryType)-1]
		}

		return nil

	} else if strings.Contains(data, state.Charge.String()) {

		eventInfo.EventInfoKey = "battery charge (percentage)"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(data)
		percentage, err := strconv.Atoi(value)
		if err != nil {
			eventInfo = nil
			return err
		}

		switch percentage {
		case 255:
			eventInfo.EventInfoValue = FLAG
		case 254:
			eventInfo.EventInfoValue = "calculating"
		default:
			eventInfo.EventInfoValue = value
		}

		return nil

	} else if strings.Contains(data, state.Bars.String()) {

		eventInfo.EventInfoKey = "battery charge (bars)"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(data)

		bars, err := strconv.Atoi(value)
		if err != nil {
			eventInfo = nil
			return err
		}

		switch bars {
		case 255:
			eventInfo.EventInfoValue = FLAG
		case 254:
			eventInfo.EventInfoValue = "calculating"
		default:
			eventInfo.EventInfoValue = value
		}
		return nil

	} else { //ignoring data, e.g battery temperature

		eventInfo.EventInfoValue = FLAG
		return nil
	}
}
