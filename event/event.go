package event

import (
	"errors"
	"strings"

	ei "github.com/byuoitav/event-router-microservice/eventinfrastructure"
	"github.com/byuoitav/shure-audio-microservice/state"
)

//wrapper for event types
type Context struct {
	E Event
}

func (c *Context) FillEventInfo(data string, eventInfo *ei.EventInfo) error {
	return c.E.FillEventInfo(data, eventInfo)
}

type Event interface {
	//Fills EventInfo.EventInfoKey, EventInfo.EventInfoValue, EventInfo.Type, and EventInfo.EventCause
	FillEventInfo(string, *ei.EventInfo) error
}

type Interference struct{}

func (p Interference) FillEventInfo(data string, eventInfo *ei.EventInfo) error {

	eventInfo.EventInfoKey = state.Interference.String()
	eventInfo.EventCause = ei.AUTOGENERATED

	if strings.Contains(data, state.None.String()) { //no interference
		eventInfo.EventInfoValue = state.None.String()
		eventInfo.Type = ei.DETAILSTATE
	} else if strings.Contains(data, state.Critical.String()) { //interference
		eventInfo.EventInfoValue = state.Critical.String()
		eventInfo.Type = ei.ERROR
	} else { //bad data
		return errors.New("Invalid interference data detected")
	}
	return nil
}

type Power struct{}

func (p Power) FillEventInfo(data string, eventInfo *ei.EventInfo) error {

	eventInfo.EventInfoKey = "Power"
	eventInfo.Type = ei.CORESTATE

	if strings.Contains(data, "UNKN") {
		eventInfo.EventInfoValue = "standby"
		eventInfo.EventCause = ei.AUTOGENERATED
	} else {
		eventInfo.EventInfoValue = "on"
		eventInfo.EventCause = ei.STARTUP
	}

	return nil
}

type Battery struct{}

func (p Battery) FillEventInfo(data string, eventInfo *ei.EventInfo) error {

	if strings.Contains(data, state.Cycles.String()) {

	} else if strings.Contains(data, state.RunTime.String()) {

	} else if strings.Contains(data, state.Type.String()) {

	} else if strings.Contains(data, state.Charge.String()) {

	} else if strings.Contains(data, state.Bars.String()) {

	} else { //bad data

	}
	return nil
}
