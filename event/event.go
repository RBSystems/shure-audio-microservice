package event

import (
	"errors"
	"log"
	"regexp"
	"strconv"
	"strings"

	"github.com/byuoitav/common/v2/events"
	"github.com/byuoitav/shure-audio-microservice/state"
	"github.com/fatih/color"
)

const FLAG = "ignored"

//wrapper for event types
type Context struct {
	E MicEvent
}

func (c *Context) FillEventInfo(data string, e *events.Event) error {
	return c.E.FillEventInfo(data, e)
}

type MicEvent interface {
	//Fills Event.Key, Event.Value, Event Tags
	//@pre: data does not contain the mic channel
	FillEventInfo(string, *events.Event) error
}

type Interference struct{}

func (p Interference) FillEventInfo(data string, e *events.Event) error {

	e.Key = "interference"
	e.AddToTags(events.AutoGenerated)

	if strings.Contains(data, state.None.String()) { //no interference
		e.Value = state.None.String()
		e.AddToTags(events.DetailState)
	} else if strings.Contains(data, state.Critical.String()) { //interference
		e.Value = state.Critical.String()
		e.AddToTags(events.Error)
	} else { //bad data
		return errors.New("Invalid interference data detected")
	}
	return nil
}

type Power struct{}

func (p Power) FillEventInfo(data string, e *events.Event) error {

	e.Key = "power"
	e.AddToTags(events.CoreState)

	if strings.Contains(data, "UNKN") {
		e.Value = "standby"
		e.AddToTags(events.AutoGenerated)
	} else {
		e.Value = "on"
		e.AddToTags(events.StartUp)
	}

	return nil
}

type Battery struct{}

func (p Battery) FillEventInfo(data string, e *events.Event) error {

	log.Printf("Filling battery event info for message %s...", data)

	e.AddToTags(events.DetailState)
	e.AddToTags(events.AutoGenerated)

	if strings.Contains(data, state.Cycles.String()) {

		e.Key = "battery cycles"
		re := regexp.MustCompile("[1-9][0-9]*")
		batteryCycles := re.FindString(data)
		color.Set(color.FgYellow)
		log.Printf("Found cycles: %s", batteryCycles)
		color.Unset()

		switch batteryCycles {
		case "65535":
			e.Value = FLAG
		case "":
			e.Value = "0"
		default:
			e.Value = batteryCycles
		}

		return nil

	} else if strings.Contains(data, state.RunTime.String()) {

		e.Key = "battery charge (minutes remaining)"
		re := regexp.MustCompile("[1-9][0-9]*")
		runTime := re.FindString(data)

		color.Set(color.FgYellow)
		log.Printf("Found run time: %s", runTime)
		color.Unset()

		switch runTime {
		case "65535":
			e.Value = FLAG
		case "65534":
			e.Value = "calculating"
		case "":
			e.Value = "0"
		default:
			e.Value = runTime
		}

		return nil

	} else if strings.Contains(data, state.Type.String()) {

		e.Key = "battery type"

		re := regexp.MustCompile("[\\s][A-Z]{4}[\\s]")
		batteryType := re.FindString(data)

		if batteryType == " UNKN " {
			e.Value = "Unknown"
		} else {
			e.Value = batteryType[1 : len(batteryType)-1]
		}

		return nil

	} else if strings.Contains(data, state.Charge.String()) {

		e.Key = "battery charge (percentage)"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(data)
		percentage, err := strconv.Atoi(value)
		if err != nil {
			e = nil
			return err
		}

		switch percentage {
		case 255:
			e.Value = FLAG
		case 254:
			e.Value = "calculating"
		default:
			e.Value = value
		}

		return nil

	} else if strings.Contains(data, state.Bars.String()) {

		e.Key = "battery charge (bars)"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(data)

		bars, err := strconv.Atoi(value)
		if err != nil {
			e = nil
			return err
		}

		switch bars {
		case 255:
			e.Value = FLAG
		case 254:
			e.Value = "calculating"
		default:
			e.Value = value
		}
		return nil

	} else { //ignoring data, e.g battery temperature

		e.Value = FLAG
		return nil
	}
}
