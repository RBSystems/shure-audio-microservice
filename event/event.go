package event

import (
	"errors"
	"log"
	"regexp"
	"strconv"
	"strings"

	ei "github.com/byuoitav/event-router-microservice/eventinfrastructure"
	"github.com/byuoitav/shure-audio-microservice/state"
)

//wrapper for event types
type Context struct {
	E Event
}

func (c *Context) FillEventInfo(data string, eventInfo *ei.EventInfo) error {
	return c.E.FillEventInfo(data, eventInfo)
}

type Event interface {
	//Fills EventInfo.EventInfoKey, EventInfo.EventInfoValue, EventInfo.Type, and EventInfo.EventCause
	//@pre: data does not contain the mic channel
	FillEventInfo(string, *ei.EventInfo) error
}

type Interference struct{}

func (p Interference) FillEventInfo(data string, eventInfo *ei.EventInfo) error {

	eventInfo.EventInfoKey = state.Interference.String()
	eventInfo.EventCause = ei.AUTOGENERATED

	if strings.Contains(data, state.None.String()) { //no interference
		eventInfo.EventInfoValue = state.None.String()
		eventInfo.Type = ei.DETAILSTATE
	} else if strings.Contains(data, state.Critical.String()) { //interference
		eventInfo.EventInfoValue = state.Critical.String()
		eventInfo.Type = ei.ERROR
	} else { //bad data
		return errors.New("Invalid interference data detected")
	}
	return nil
}

type Power struct{}

func (p Power) FillEventInfo(data string, eventInfo *ei.EventInfo) error {

	eventInfo.EventInfoKey = "Power"
	eventInfo.Type = ei.CORESTATE

	if strings.Contains(data, "UNKN") {
		eventInfo.EventInfoValue = "standby"
		eventInfo.EventCause = ei.AUTOGENERATED
	} else {
		eventInfo.EventInfoValue = "on"
		eventInfo.EventCause = ei.STARTUP
	}

	return nil
}

type Battery struct{}

func (p Battery) FillEventInfo(data string, eventInfo *ei.EventInfo) error {

	log.Printf("Filling battery event info for message %s...", data)

	eventInfo.Type = ei.DETAILSTATE
	eventInfo.EventCause = ei.AUTOGENERATED

	if strings.Contains(data, state.Cycles.String()) {

		eventInfo.EventInfoKey = "battery cycles"
		re := regexp.MustCompile("[\\d]{5}")
		eventInfo.EventInfoValue = re.FindString(data)
		return nil

	} else if strings.Contains(data, state.RunTime.String()) {

		eventInfo.EventInfoKey = "remaining battery time"
		re := regexp.MustCompile("[\\d]{5}]")
		switch re.FindString(data) {
		case "65535":
			eventInfo.EventInfoValue = "unknown"
		case "65534":
			eventInfo.EventInfoValue = "calculating"
		default:
			eventInfo.EventInfoValue = re.FindString(data)
		}

		return nil

	} else if strings.Contains(data, state.Type.String()) {

		eventInfo.EventInfoKey = "battery Type"

		if strings.Contains(data, "LION") {
			eventInfo.EventInfoValue = "SB900"
		} else if strings.Contains(data, "ALKA") {
			eventInfo.EventInfoValue = "AA"
		} else {
			eventInfo.EventInfoValue = "Other"
		}

		return nil

	} else if strings.Contains(data, state.Charge.String()) {

		eventInfo.EventInfoKey = "battery charge (percentage)"
		re := regexp.MustCompile("[\\d^0]+")
		value := re.FindString(data)
		percentage, err := strconv.Atoi(value)
		if err != nil {
			eventInfo = nil
			return err
		}

		if percentage < 0 || percentage > 100 {
			eventInfo.EventInfoValue = "unknown"
		} else {
			eventInfo.EventInfoValue = value
		}

		return nil

	} else if strings.Contains(data, state.Bars.String()) {

		eventInfo.EventInfoKey = "battery bars"
		re := regexp.MustCompile("[\\d^0]+")
		value := re.FindString(data)
		if len(value) == 0 {
			eventInfo.EventInfoValue = "0"
		}

		bars, err := strconv.Atoi(value)
		if err != nil {
			eventInfo = nil
			return err
		}

		if bars < 0 || bars > 5 {
			eventInfo.EventInfoValue = "calculating"
		} else {
			eventInfo.EventInfoValue = value
		}
		return nil

	} else { //ignoring data, e.g battery temperature

		eventInfo = nil
		return nil
	}
	return nil
}
